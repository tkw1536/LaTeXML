# -*- mode: Perl -*-
# /=====================================================================\ #
# |  article                                                            | #
# | Implementation for LaTeXML                                          | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;

LoadPool('LaTeX');

#**********************************************************************
# Ignoring all the options for now

RawTeX(<<'EoTeX');
\ProvidesClass{beamer}[2021/03/19 v3.62 A class for typesetting presentations]
EoTeX

# argument for beamer overlays
DefParameterType('BeamerOverlay', sub {
   my ($gullet) = @_;
   my $tok = $gullet->readXToken;
   if (ref $tok && ToString($tok) eq '<') {
     $gullet->readUntil(T_OTHER('>'));
   } else {
     $gullet->unread($tok) if ref $tok;
     undef; }},
     reversion=> sub {
 (T_OTHER('<'), $_[0]->revert, T_OTHER('>'));
       });

#**********************************************************************
# Mode support

# Beamer has five modes: beamer, second, handout, trans, article.
# The \mode command allows showing content only in specific modes.
# It can also take the 'all' argument (stuff visible in any mode) or 'presentation' (anything except article).
# We call these a compound mode, the above a leaf mode.
#
# In real tex, only one mode is active at a time.
# In latexml we activate all modes at the same time and guard visibility using the target format
# (e.g. in CSS set display:none) etc.

# TeX itself assumes a leaf mode in the 'beamer@mode' macro.
# when switching to 'all' or 'presentation' compound modes, we must pick one of them here.
AssignValue('beamer@mode@leaf@all', 'beamer');
AssignValue('beamer@mode@leaf@presentation', 'beamer');
sub pickLeafMode {
  my ($mode) = @_;
  return LookupValue('beamer@mode@leaf@all') if $mode eq 'all';
  return LookupValue('beamer@mode@leaf@presentation') if $mode eq 'presentation';
  $mode; }
# The beamer@@mode wraps content in a specific mode.
# It is responsible for setting the 'beamer@mode' macro appropriatly.
DefEnvironment('{beamer@@mode}{}', "<ltx:para class='inmode #mode'>#body</ltx:para>", properties => sub {
  my ($stomach, $mode) = @_;
  return (mode => ToString($mode)) }, 
# TODO: Set internal \if s here (like beamer@presentation) etc
afterDigestBegin => sub {
  my ($stomach, $whatsit) = @_;
  DefMacro('\beamer@mode', pickLeafMode($whatsit->getProperty('mode'))); });

# Define a 'beamer@ltxmode' value to hold the current (leaf or compound) mode.
# And a switch-mode macro responsible for maintaining it and wrapping in the beamer@@mode environment.
DefMacro('\beamer@switchmode{}', sub {
  my ($gullet, $mode) = @_;
  my $newMode = ToString($mode);
  my $currentMode = LookupValue('beamer@ltxmode');
  my @return = ();
  # if we are not in the 'all' mode, we need to close whatever mode we are in
  push(@return, T_CS('\beamer@mode@close')) unless ($currentMode eq 'all');
  # if the new mode isn't 'all', we need to switch to it!
  push(@return, (T_CS('\beamer@mode@open'), T_BEGIN, $mode->revert, T_END)) unless ($newMode eq 'all');
  AssignValue('beamer@ltxmode', $newMode, 'global');
  @return; });

DefMacro('\beamer@mode@open{}', '\begin{beamer@@mode}{#1}');
DefMacro('\beamer@mode@close', '\end{beamer@@mode}');

# we are in 'all' mode now, and should be back at it before the document ends.
AssignValue('beamer@ltxmode', 'all', 'global');
AtEndDocument(T_CS('\beamer@switchmode'), T_BEGIN, Tokenize('all'), T_END);

# '\mode' switches the current mode, either until the next \mode, or for a specific block
DefMacro('\mode OptionalMatch:* OptionalBeamerOverlay Optional {}', sub {
  my ($gullet, $star, $overlay, $arg) = @_;
  $DB::single = 1;
  if(defined($star)) {
    # \mode* takes no arguments and just "hides" text outside of presentation mode
    # TODO: Figure out if we want to do something with that
    return $arg->revert if defined($arg);
    return }
  # in other modes, we require the overlay specification, so bail out if it's missing!
  unless(defined($overlay)) {
    Warn('expected', '<', undef, "Expected mode specification");
    return; }
  # explicit body => switchmode, add the body, and switch back
  if(defined($arg)) {
    return (
      T_CS('\beamer@switchmode'), T_BEGIN, Tokenize(ToString($overlay)), T_END,
      $arg->revert,
      T_CS('\beamer@switchmode'), T_BEGIN, Tokenize(LookupValue('beamer@mode')), T_END,
    ); }
  # else we switch the mode
  return (T_CS('\beamer@switchmode'), T_BEGIN, Tokenize(ToString($overlay)), T_END); });


#**********************************************************************
# Frames - the main environment for beamer

# I don't know what defined the environment, but it's already here!
RawTeX(<<'EoTeX');
\renewenvironment{frame}{\begin{beamer@frame}\beamer@frame@begin}{\beamer@frame@end\end{beamer@frame}}
EoTeX

# the actual frame environemnt
DefEnvironment('{beamer@frame}[]', "<ltx:slide class='frame'>#body</ltx:slide>");

DefMacro('\beamer@frame@begin',   
  '\setcounter{beamer@slideinframe}{0}' . # reset the counter for current frames
  '\beamer@overlay@begin'); # immediatly start a new overlay!
DefMacro('\beamer@frame@end', '\beamer@overlay@end'); # end an

DefConstructor('\frametitle{}', '<ltx:title>#1</ltx:title>');
DefConstructor('\framesubtitle{}', '<ltx:subtitle>#1</ltx:subtitle>');

#**********************************************************************
# Overlays

# These in principle insert a <ltx:block class="ltx_overlay"> into the right places. 
# The tricky part is getting the starting and ending right.

# TODO: Pass arguments for what kind of overlay it is here!
DefConstructor('\beamer@overlay@begin', "<ltx:block class='ltx_overlay'>");
DefConstructor('\beamer@overlay@end', '</ltx:block>');

DefMacro('\pause', '\beamer@overlay@end\addtocounter{beamer@slideinframe}{1}\beamer@overlay@begin');
DefMacro('\uncover', '\beamer@overlay@end\addtocounter{beamer@slideinframe}{1}\beamer@overlay@begin');

#**********************************************************************
# Overlay Specifications


my $overlayParser = Parse::RecDescent->new(<<'EOGRAMMAR');
start : 
    modespec(s /|,/)

# a single mode specification is either a mode, a sliderange, or both
modespec : 
      MODE '@' frames   { $return = [ "mode" => $item[1], "frames" => $item[3] ] }
    | MODE                  { $return = [ "mode" => $item[1], "frames" => undef    ] }
    | frames            { $return = [ "mode" => undef,    "frames" => $item[1] ] }

# a range of slides
frames : 
      framenumber '-' framenumber { $return = [ "kind" => "range", "from"   => $item[1], "to" => $item[3] ] }
    | '-' framenumber             { $return = [ "kind" => "range", "from"   => undef,    "to" => $item[2] ] }
    | framenumber '-'             { $return = [ "kind" => "range", "from"   => $item[1], "to" => undef    ] }
    | framenumber                 { $return = [ "kind" => "point", "value"  => $item[1]                   ] }

framenumber : 
      relative  { $return = [ "kind" => "relative", "value" => $item[1] ] }
    | POSINT    { $return = [ "kind" => "absolute", "value" => $item[1] ] }

# relative specification - denoted by either a '.' or '+'
relative : 
      MODIFIER '(' INT ')' { $return = [ "modifier" => $item[1], "offset" => $item[3] ] }
    | MODIFIER             { $return = [ "modifier" => $item[1], "offset" => undef    ] }


# positive and normal integers => return the kind integer
INT       : /-?[0-9]*/    { $return = $item[1] + 0 }
POSINT    : /[1-9][0-9]*/ { $return = $item[1] + 0 }

MODIFIER  : '.' | '+'
MODE      : 'all' | 'presentation' | 'article' | 'beamer' | 'second' | 'handout' | 'trans' | 'alert'

EOGRAMMAR

# parses and processes an overlay specification
sub parseOverlaySpec {
  my ($spec, $lastPlus) = @_;
  $spec =~ s/\s//g;
  my ($ast) = $overlayParser->start($spec);
  return undef, $lastPlus unless defined($ast);
  return processOverlaySpec($ast, $lastPlus); }

sub stringifyOverlaySpec {
  my ($spec) = @_;
  return "" unless defined($spec);
  my @strings = map {
    my @data = @{$_};
    my $count = scalar @data;
    my $return = "";
    if ($count == 1) {
      $return = $data[0];
    } elsif ($count == 2) {
      $return .= $data[0] . "\@" if (defined($data[0]));
      $return .= $data[1];
    } elsif ($count == 3) {
      $return .= $data[0] . "\@" if (defined($data[0]));
      $return .= $data[1] if (defined($data[1]));
      $return .= "-";
      $return .= $data[2] if (defined($data[2]));
    }
    $return
  } @$spec;
  return join(',', @strings);
}

# resolves a single point
sub resolvePoint {
  my ($point, $lastPlus) = @_;
  return undef, $lastPlus unless defined($point); # no point defined
  my %data = @$point;
  return $data{'value'}, $lastPlus if ($data{'kind'} eq 'absolute'); # point is absolute
  %data = $data{'value'};
  my ($modifier, $offset) = ($data{'modifier'}, $data{'offset'});
  if ($modifier eq '.') { # use, but don't increment
    $offset = 0 unless defined($offset);
    return $lastPlus + $offset, $lastPlus; } 
  else { # use and increment
    $offset = 1 unless defined($offset);
    $lastPlus = $lastPlus + $offset;
    return $lastPlus, $lastPlus; } }

# parses and processses an overlay spec
sub processOverlaySpec {
  my ($ast, $lastPlus) = @_;
  my (@mapped) = map {
    my %data = @{$_};
    my $mode = $data{'mode'};
    my $frames = $data{'frames'};
    if(defined($frames)) { #
      my ($start, $end);
      my %frames = @$frames;
      if ($frames{'kind'} eq 'point') { # just a point
        ($start, $lastPlus) = resolvePoint($frames{'value'}, $lastPlus);
        $end = $start; }
      else { # actual range
        ($start, $lastPlus) = resolvePoint($frames{'from'}, $lastPlus);
        ($end, $lastPlus) = resolvePoint($frames{'to'}, $lastPlus); }
      [$mode, $start, $end] }
    else {
      [$mode] } 
  } @$ast;
  return [@mapped], $lastPlus; }

# count the current frame number (the last "+" to be encountered)
NewCounter('beamer@slideinframe');

# TODO: This needs to be made an <ltx:overlay> or ltx:slide inside an ltx:frame, but that needs schema changes
# so we're omitting it for now
DefConstructor('\only BeamerOverlay {}', "<ltx:para class='#indexes'>#2</ltx:para>", properties => sub {
  my ($stomach, $overlay) = @_;
  my ($spec);
  # read an store $lastPlus
  my $lastPlus = CounterValue('beamer@slideinframe')->valueOf;
  ($spec, $lastPlus) = parseOverlaySpec(ToString($overlay), $lastPlus);
  SetCounter('beamer@slideinframe', Number($lastPlus));
  # and store the indexes in the DOM!
  (indexes => stringifyOverlaySpec($spec));
});

#**********************************************************************
# Dependencies

RequirePackage('ifpdf');
#RequirePackage('pgfcore');
#RequirePackage('xxcolor');

#**********************************************************************
# Beamer Theorems beamerbastheorem
RequirePackage('amsthm');
RequirePackage('amsmath');

# TODO '\qedhere' (and where it comes from!)
RequirePackage('hyperref', options => ['bookmarks=true', 'bookmarksopen=true', 'pdfborder={0 0 0}', 'pdfhighlight={/N}', 'linkbordercolor={.5 .5 .5}']);

#**********************************************************************
# Document structure.
RelaxNGSchema("LaTeXML"); # TODO: Re-enable this!
# RequireResource('ltx-article.css');

# ignore all the styling
DefMacro('\setbeamertemplate{}[] Optional {}', undef);
DefMacro('\setbeamercolor{}{}', undef);
DefMacro('\setbeamerfont{}{}', undef);

#**********************************************************************
# Core sectioning support, stolen from article.cls!
SetCounter('secnumdepth', Number(3));
NewCounter('part',          'document',      idprefix => 'Pt',  nested => ['section']);
NewCounter('section',       'document',      idprefix => 'S',   nested => ['subsection']);
NewCounter('subsection',    'section',       idprefix => 'SS',  nested => ['subsubsection']);
NewCounter('subsubsection', 'subsection',    idprefix => 'SSS', nested => ['paragraph']);
NewCounter('paragraph',     'subsubsection', idprefix => 'P',   nested => ['subparagraph']);
NewCounter('subparagraph', 'paragraph', idprefix => 'SP', nested => ['equation', 'figure', 'table']);

DefMacro('\thepart',          '\Roman{part}');
DefMacro('\thesection',       '\arabic{section}');
DefMacro('\thesubsection',    '\thesection.\arabic{subsection}');
DefMacro('\thesubsubsection', '\thesubsection.\arabic{subsubsection}');
DefMacro('\theparagraph',     '\thesubsubsection.\arabic{paragraph}');
DefMacro('\thesubparagraph',  '\theparagraph.\arabic{subparagraph}');
SetCounter(tocdepth => Number(3));

NewCounter('equation',       'document', idprefix => 'E',  idwithin => 'section');
NewCounter('@equationgroup', 'document', idprefix => 'EG', idwithin => 'section');
NewCounter('figure',         'document', idprefix => 'F',  idwithin => 'section');
NewCounter('table',          'document', idprefix => 'T',  idwithin => 'section');

DefMacro('\theequation', '\arabic{equation}');
DefMacro('\thefigure',   '\arabic{figure}');
DefMacro('\thetable',    '\arabic{table}');

NewCounter('enumi',   undef, idwithin => '@itemizei', idprefix => 'i');
NewCounter('enumii',  undef, idwithin => 'enumi',     idprefix => 'i');
NewCounter('enumiii', undef, idwithin => 'enumii',    idprefix => 'i');
NewCounter('enumiv',  undef, idwithin => 'enumiii',   idprefix => 'i');
DefMacro('\theenumi',   '\arabic{enumi}');
DefMacro('\theenumii',  '\alph{enumii}');
DefMacro('\theenumiii', '\roman{enumiii}');
DefMacro('\theenumiv',  '\Alph{enumiv}');

DefMacro('\refname', 'References');

AssignMapping('BACKMATTER_ELEMENT', 'ltx:bibliography' => 'ltx:section');

Tag('ltx:appendix', autoClose => 1);
DefMacro('\appendix', '\@appendix');
# Actually we should be using section counter
DefPrimitive('\@appendix', sub { startAppendices('section'); });


#**********************************************************************
1;
